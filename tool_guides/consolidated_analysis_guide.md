# Сводное руководство по флагам и проверкам инструментов анализа

Данное руководство объединяет рекомендуемые флаги и конфигурации для различных инструментов статического и динамического анализа, используемых в проекте. Цель — обеспечить максимальное покрытие потенциальных проблем при минимизации избыточности проверок между инструментами.

## 1. Инструменты статического анализа

Статический анализ выполняется без запуска кода и помогает выявить проблемы на ранних этапах.

### 1.1. Clang-Tidy

**Назначение (из README.md):** Обнаружение и исправление типичных ошибок программирования, проверка соответствия стандартам кодирования.

**Рекомендуемые флаги и проверки:**

Clang-Tidy использует систему чеков, которые можно включать или выключать. Рекомендуется начать с набора по умолчанию и добавлять специфичные для проекта или стиля кодирования.

Пример запуска через `run-clang-tidy.py` (часто поставляется с LLVM/Clang) или интеграции с CMake:

```bash
# Пример команды (может отличаться в зависимости от интеграции)
clang-tidy <source-file.cpp> --checks='-*,clang-analyzer-*,modernize-*,performance-*,readability-*,portability-*,cppcoreguidelines-*' -- -std=c++17 -I/path/to/includes
```

**Ключевые группы проверок для включения (префикс `*` для включения всех в группе, `-` для исключения):**

*   **`clang-analyzer-*`**: Глубокие проверки от Clang Static Analyzer, интегрированные в Clang-Tidy. Очень важны для поиска сложных ошибок.
*   **`modernize-*`**: Помогает модернизировать код до современных стандартов C++ (например, `modernize-use-nullptr`, `modernize-use-auto`).
*   **`performance-*`**: Обнаруживает потенциальные проблемы производительности (например, `performance-inefficient-vector-operation`).
*   **`readability-*`**: Улучшает читаемость кода (например, `readability-identifier-naming`).
*   **`portability-*`**: Выявляет проблемы, связанные с переносимостью кода.
*   **`cppcoreguidelines-*`**: Проверки на соответствие C++ Core Guidelines.
*   **`bugprone-*`**: Обнаруживает конструкции, склонные к ошибкам (например, `bugprone-use-after-move`, `bugprone-integer-division-by-zero`).

**Конфигурация:**
Создайте файл `.clang-tidy` в корне проекта для централизованной конфигурации чеков:
```yaml
Checks: '-*,clang-analyzer-*,modernize-*,performance-*,readability-*,portability-*,cppcoreguidelines-*,bugprone-*'
HeaderFilterRegex: '.*'
AnalyzeTemporaryDtors: true
FormatStyle: file # или llvm, google, etc.
# Дополнительные опции по необходимости
```

**Минимизация дублирования:**
*   Clang-Tidy покрывает многие аспекты, которые также могут проверяться Cppcheck или OCLint. Если Clang-Tidy используется с обширным набором чеков, можно уменьшить количество активных проверок в Cppcheck, сосредоточив его на уникальных для него областях.

### 1.2. Cppcheck

**Назначение (из README.md):** Обнаружение ошибок, которые компиляторы обычно не находят; потенциальные утечки памяти, переполнения буфера (статически), использование неинициализированных переменных.

**Рекомендуемые флаги:**

```bash
cppcheck --enable=all --std=c++17 --platform=unix64 # или win64 
         --inline-suppr --error-exitcode=1 
         --xml --xml-version=2 --output-file=cppcheck_report.xml 
         <source_paths>
```

*   **`--enable=all`**: Включает большинство проверок (warning, style, performance, portability). Можно начать с `--enable=warning,performance` и добавлять по мере необходимости.
    *   `warning`: Основные предупреждения об ошибках.
    *   `style`: Предупреждения о стиле кода (могут пересекаться с Clang-Format и Clang-Tidy, используйте с осторожностью или настройте).
    *   `performance`: Потенциальные проблемы производительности.
    *   `portability`: Проблемы переносимости.
    *   `information`: Информационные сообщения (менее критичные).
    *   `unusedFunction`: Поиск неиспользуемых функций (может быть полезно).
*   **`--std=c++17`** (или актуальный стандарт проекта).
*   **`--platform=unix64`** (или `win64`, `native`): Важно для точности анализа, особенно для типов данных и API.
*   **`--inline-suppr`**: Разрешает подавление предупреждений прямо в коде.
*   **`--suppressions-list=suppressions.txt`**: Для централизованного списка подавлений.
*   **`--error-exitcode=1`**: Важно для CI, чтобы пайплайн падал при наличии ошибок.
*   **`--xml --xml-version=2`**: Для генерации отчета в формате XML, удобного для парсинга.
*   **`--check-config`**: Для проверки конфигурации и нераспознанных файлов.

**Минимизация дублирования:**
*   Cppcheck хорош в поиске некоторых видов утечек памяти и проблем с неинициализированными переменными на статическом уровне. Если MSan используется активно, фокус Cppcheck на неинициализированных переменных может быть снижен. ASan и Valgrind более надежны для утечек памяти, но Cppcheck может дать ранние указания.
*   Некоторые проверки `style` могут дублировать Clang-Tidy. Отдавайте предпочтение Clang-Tidy для стилевых вопросов, если он активно используется.

### 1.3. Clang Static Analyzer (CSA)

**Назначение (из README.md):** Глубокий, контекстно-зависимый анализ кода, выявление сложных логических ошибок и уязвимостей.

**Рекомендуемые флаги и проверки:**

CSA обычно вызывается через `scan-build` или напрямую через Clang.

```bash
# Через scan-build (рекомендуется для удобства)
scan-build -o ./clang_analyzer_report --status-bugs <команда_сборки_проекта>
# Например: scan-build -o ./clang_analyzer_report make

# Прямой вызов (более сложная настройка)
clang --analyze <source-file.cpp> -Xanalyzer <checker_options>
```

**Ключевые группы чекеров (включаются по умолчанию многие, но можно тюнинговать):**
*   Большинство полезных чекеров включены по умолчанию при использовании `scan-build`.
*   Чекерами можно управлять через опции `-Xanalyzer -analyzer-checker=alpha.core.PointerArithm` или `-Xanalyzer -analyzer-disable-checker=alpha.core.PointerArithm`.
*   **Основные группы (многие включены по умолчанию):** `core`, `unix`, `osx`, `security`, `deadcode`, `cplusplus`.
*   **Экспериментальные/дополнительные чекеры (`alpha.*`)**: Могут быть полезны, но могут давать больше ложных срабатываний. Включайте выборочно.
    *   Пример: `alpha.clone.CloneChecker` (поиск дублирующегося кода).

**Минимизация дублирования:**
*   CSA интегрирован в Clang-Tidy через чеки `clang-analyzer-*`. Если вы активно используете эти чеки в Clang-Tidy, отдельный запуск `scan-build` может быть избыточным или использоваться для более глубокого анализа периодически.
*   CSA превосходит Cppcheck в глубине анализа путей выполнения.

### 1.4. OCLint

**Назначение (из README.md):** Улучшение качества и поддерживаемости кода, обнаружение сложного кода, проверка на соответствие стандартам.

**Рекомендуемые флаги:**

```bash
oclint <source_files> -- -std=c++17 -I/path/to/includes \
    -report-type html -o oclint_report.html \
    -rc=<RULE_CONFIGURATION_OPTION>=<VALUE> \
    -enable-global-analysis \
    -enable-clang-static-analyzer # Если не используется отдельно scan-build
```

*   **`-rc=<RULE_NAME>=<VALUE>`**: Настройка порогов для правил (например, `LONG_LINE=120`, `CYCLOMATIC_COMPLEXITY=15`).
*   **`-enable-global-analysis`**: Для более точного анализа, но может замедлить процесс.
*   **`-enable-clang-static-analyzer`**: Интегрирует проверки CSA. Если CSA уже запускается отдельно или через Clang-Tidy, эту опцию можно опустить.
*   **Правила по умолчанию** обычно включают проверки на:
    *   Размер и сложность функций/классов.
    *   Неиспользуемый код.
    *   Соглашения по именованию (могут пересекаться с Clang-Tidy).
    *   Пустые блоки if/else/try/catch.

**Минимизация дублирования:**
*   OCLint фокусируется на метриках кода (сложность, длина и т.д.) и некоторых паттернах. Clang-Tidy с `readability-*` и `maintainability-*` (если есть) может покрывать часть этих аспектов.
*   Если Clang-Tidy используется для форматирования и базовых проверок читаемости, OCLint может быть сконцентрирован на более сложных метриках и специфичных правилах, не покрываемых Clang-Tidy.

### 1.5. Include-what-you-use (IWYU)

**Назначение (из README.md):** Оптимизация директив `#include`, уменьшение времени компиляции и зависимостей.

**Рекомендуемые флаги:**

IWYU обычно интегрируется в систему сборки (например, CMake) или запускается с помощью `iwyu_tool.py`.

```bash
# Пример с iwyu_tool.py (требует compile_commands.json)
iwyu_tool.py -p . -j <num_threads> --fix_includes

# Прямой вызов (для одного файла)
include-what-you-use <source_file.cpp> -Xiwyu --transitive_includes_only -Xiwyu --mapping_file=my_mappings.imp -std=c++17 -- -I/path/to/includes
```

*   **`-Xiwyu --transitive_includes_only`**: Рекомендует удалять заголовочные файлы, которые включены транзитивно и не нужны напрямую.
*   **`-Xiwyu --mapping_file=<file.imp>`**: Файл для указания маппингов (например, какой публичный заголовок предоставляет какой символ).
*   **`-Xiwyu --quoted_includes_first`**: Предпочитать кавычки для локальных заголовков.
*   **`--fix_includes`** (с `iwyu_tool.py`): Автоматически применяет предложенные изменения.

**Минимизация дублирования:**
*   IWYU уникален в своей задаче. Другие статические анализаторы обычно не фокусируются на оптимизации `#include` директив.

## 2. Инструменты динамического анализа

Динамический анализ выполняется во время работы программы и помогает выявить ошибки, проявляющиеся только при исполнении.

### 2.1. Valgrind

**Назначение (из README.md):** Обнаружение утечек памяти (Memcheck), профилирование (Callgrind/Cachegrind), обнаружение гонок данных (Helgrind/DRD).

**Рекомендуемые конфигурации:**

*   **Memcheck (для утечек памяти и ошибок доступа к памяти):**
    ```bash
    valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose <your_program> [args]
    ```
    *   `--leak-check=full`: Наиболее полный анализ утечек.
    *   `--show-leak-kinds=all`: Показывает все типы утечек (definite, indirect, possible, still-reachable).
    *   `--track-origins=yes`: Помогает отследить источник неинициализированных значений.
    *   `--verbose`: Более подробный вывод.

*   **Helgrind/DRD (для гонок данных):**
    ```bash
    valgrind --tool=helgrind <your_program> [args]
    # или
    valgrind --tool=drd <your_program> [args]
    ```
    *   Helgrind и DRD являются альтернативами TSan. TSan обычно имеет меньшие накладные расходы.

**Минимизация дублирования:**
*   **Memcheck vs ASan:** ASan обычно быстрее и может находить некоторые ошибки, которые Memcheck пропускает (и наоборот). Рекомендуется использовать ASan как основной инструмент для ошибок памяти из-за его скорости, а Memcheck — для более глубокого анализа или когда ASan недоступен/не подходит.
*   **Helgrind/DRD vs TSan:** TSan обычно предпочтительнее для обнаружения гонок данных из-за меньших накладных расходов и лучшей интеграции с компилятором.

### 2.2. Sanitizers (ASan, TSan, MSan, UBSan)

**Назначение (из README.md):** Высокоэффективные инструменты для обнаружения ошибок времени выполнения с низкими накладными расходами.

**Рекомендуемые флаги компиляции и линковки (для Clang/GCC):**

*   **AddressSanitizer (ASan):** Ошибки доступа к памяти.
    ```bash
    # Компиляция и линковка
    clang++ -fsanitize=address -g -O1 ...
    # Переменные окружения для настройки (опционально)
    export ASAN_OPTIONS=detect_leaks=1:halt_on_error=1
    ```
    *   `-fsanitize=address`: Включает ASan.
    *   `-g`: Для получения информации об отладке (номера строк).
    *   `-O1` или выше: Рекомендуется для лучшей производительности с ASan.
    *   `detect_leaks=1`: Включает детектор утечек (LSan), который является частью ASan.

*   **ThreadSanitizer (TSan):** Гонки данных.
    ```bash
    # Компиляция и линковка
    clang++ -fsanitize=thread -g -O1 ...
    # Переменные окружения (опционально)
    export TSAN_OPTIONS=report_bugs=1:second_deadlock_stack=1
    ```
    *   Несовместим с ASan/MSan (нельзя использовать одновременно в одной сборке).

*   **MemorySanitizer (MSan):** Чтения из неинициализированной памяти.
    ```bash
    # Компиляция и линковка
    clang++ -fsanitize=memory -fPIE -pie -g -O1 ...
    # Переменные окружения (опционально)
    export MSAN_OPTIONS=exit_code=86:log_path=msan.log
    ```
    *   Требует инструментирования всех библиотек, с которыми линкуется программа, что может быть сложно.
    *   Несовместим с ASan/TSan.

*   **UndefinedBehaviorSanitizer (UBSan):** Неопределенное поведение.
    ```bash
    # Компиляция и линковка
    clang++ -fsanitize=undefined -g ...
    # Можно комбинировать с ASan: -fsanitize=address,undefined
    # Переменные окружения (опционально)
    export UBSAN_OPTIONS=print_stacktrace=1:halt_on_error=1
    ```
    *   `-fsanitize=undefined` включает набор проверок по умолчанию. Можно указать конкретные:
        *   `alignment`, `bool`, `bounds`, `enum`, `float-cast-overflow`, `float-divide-by-zero`, `integer-divide-by-zero`, `nonnull-attribute`, `null`, `object-size`, `return`, `returns-nonnull-attribute`, `shift`, `signed-integer-overflow`, `unreachable`, `vla-bound`, `vptr`.
    *   Рекомендуется начать с `-fsanitize=undefined` и добавлять/исключать по необходимости.

**Минимизация дублирования:**
*   **ASan** является основным инструментом для ошибок памяти и утечек (с `detect_leaks=1`).
*   **TSan** является основным инструментом для гонок данных.
*   **MSan** специфичен для неинициализированных чтений; Cppcheck и Clang Static Analyzer могут находить некоторые из них статически, но MSan делает это динамически и более надежно.
*   **UBSan** ловит широкий спектр неопределенного поведения, которое другие инструменты могут не заметить.

## 3. Стратегия комбинирования инструментов

1.  **CI Pipeline - Быстрые проверки:**
    *   **Clang-Format:** (Не анализатор, но важен) Проверка форматирования на каждом коммите.
    *   **Clang-Tidy:** С основным набором быстрых и критичных проверок (например, `bugprone-*`, `clang-analyzer-*` выборочно, `cppcoreguidelines-*`).
    *   **Cppcheck:** С флагами `warning`, `performance`.
    *   **UBSan:** Включен в сборку для тестов (если тесты покрывают значительную часть кода).
    *   **ASan:** Включен в сборку для тестов (с `detect_leaks=1`).

2.  **CI Pipeline - Полные проверки (например, ночные сборки или по запросу):**
    *   **Clang-Tidy:** С полным набором сконфигурированных проверок.
    *   **Cppcheck:** С `--enable=all`.
    *   **Clang Static Analyzer (`scan-build`):** Для глубокого анализа.
    *   **OCLint:** Для анализа метрик и специфичных правил.
    *   **IWYU:** Для проверки и оптимизации include-директив.
    *   **TSan:** Отдельная сборка для тестов с TSan для многопоточных частей.
    *   **MSan:** Отдельная сборка для тестов с MSan (если применимо и настроено).
    *   **Valgrind Memcheck:** Для дополнительной проверки утечек и ошибок памяти, особенно если есть подозрения, что ASan что-то упускает, или для окружений, где ASan не применим.

3.  **Локальная разработка:**
    *   Интеграция Clang-Tidy и Clang-Format в IDE.
    *   Периодический запуск Cppcheck.
    *   Использование ASan/UBSan при отладке и тестировании.

Эта стратегия позволяет получить быструю обратную связь на коммиты и проводить более тщательный анализ менее часто, чтобы сбалансировать скорость разработки и качество кода.