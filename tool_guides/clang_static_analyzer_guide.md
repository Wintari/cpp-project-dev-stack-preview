# Руководство по запуску Clang Static Analyzer

## 1. Назначение и роль в проекте

Clang Static Analyzer (CSA) — это инструмент статического анализа, встроенный в Clang. Он предназначен для глубокого, контекстно-зависимого анализа кода с целью выявления сложных ошибок, которые другие анализаторы могут пропустить. CSA строит граф потока управления (Control Flow Graph, CFG) и граф потока данных (Data Flow Graph, DFG) для исследования различных путей выполнения кода.

**Разделение обязанностей:**
- **Глубокий анализ:** CSA специализируется на поиске сложных логических ошибок, уязвимостей (таких как разыменование нулевого указателя, использование после освобождения, утечки ресурсов) и других проблем, требующих понимания контекста выполнения.
- **Дополнение к другим анализаторам:**
    - В отличие от Clang-Tidy, который фокусируется на стиле, паттернах и более локальных ошибках, CSA проводит более глобальный анализ.
    - Дополняет Cppcheck, предлагая более глубокий анализ путей выполнения, тогда как Cppcheck может быть быстрее для широкого спектра более простых проверок.
- **Визуализация:** CSA может генерировать HTML-отчеты, которые визуализируют пути выполнения, приведшие к ошибке, что значительно упрощает понимание и исправление проблемы.

## 2. Конфигурация

Clang Static Analyzer управляется через опции командной строки, передаваемые Clang. Специального конфигурационного файла, как у Clang-Tidy, у него нет, но его поведение можно тонко настроить.

**Основные опции командной строки для запуска анализатора:**
- `clang --analyze <options> <source_file.cpp>`: Основной способ запуска.
- `-Xanalyzer <option>` или `-analyzer-opt <option>`: Передача опций непосредственно анализатору.

**Ключевые опции анализатора (`-Xanalyzer ...`):**
- `-analyzer-checker=<checker_name>`: Включает специфический чекер. Список чекеров можно получить командой `clang -cc1 -analyzer-checker-help`.
    - Примеры популярных чекеров: `core`, `unix`, `osx`, `deadcode`, `security`, `cplusplus`.
    - По умолчанию включен набор основных чекеров (`core`).
- `-analyzer-disable-checker=<checker_name>`: Отключает специфический чекер.
- `-analyzer-output=<format>`: Формат вывода. Возможные значения:
    - `text`: Текстовый вывод в stderr (по умолчанию).
    - `html`: Генерация HTML-отчета.
    - `plist`: Формат Property List (используется Xcode).
    - `plist-multi-file`: plist для каждого основного файла.
    - `sarif`: Static Analysis Results Interchange Format.
- `-analyzer-config <key>=<value>`: Настройка параметров чекеров.
    - Пример: `-analyzer-config eagerly-assume=false` (может улучшить производительность за счет точности).
    - Список опций: `clang -cc1 -analyzer-config-help`.
- `-analyzer-stats`: Вывод статистики о работе анализатора.
- `-analyzer-store=<model>`: Модель хранения (например, `region`).
- `-analyzer-constraints=<model>`: Модель ограничений (например, `range`).

**Пример включения всех доступных чекеров (может быть медленно и шумно):**
```bash
clang --analyze \
    -Xanalyzer -analyzer-checker=core \
    -Xanalyzer -analyzer-checker=alpha.core \
    -Xanalyzer -analyzer-checker=cplusplus \
    -Xanalyzer -analyzer-checker=deadcode \
    -Xanalyzer -analyzer-checker=security \
    -Xanalyzer -analyzer-checker=unix \
    # ... и другие группы чекеров по необходимости
    source_file.cpp
```
Рекомендуется начинать с набора по умолчанию и постепенно добавлять другие группы чекеров.

## 3. Запуск Clang Static Analyzer

CSA, как и Clang-Tidy, требует информации о компиляции проекта, обычно через `compile_commands.json`.

**А. Вручную (для одного файла):**
```bash
# Генерация HTML отчета для одного файла
clang --analyze -Xanalyzer -analyzer-output=html -o report_dir path/to/your/sourcefile.cpp -- -Iinclude -std=c++17
# Опции после '--' передаются компилятору (например, пути включения, стандарт)
# Отчеты будут в директории report_dir
```

**Б. Использование `scan-build` (рекомендуемый способ для проектов):**
`scan-build` — это Perl-скрипт, который обертывает процесс сборки (например, `make` или `cmake --build`) и запускает Clang Static Analyzer для каждого компилируемого файла.

**Шаг 1: Убедитесь, что `scan-build` установлен.**
Он обычно поставляется вместе с Clang.

**Шаг 2: Запуск `scan-build`:**
```bash
# Пример с CMake (предполагается, что проект уже сконфигурирован CMake)
# -o <output_dir>: директория для HTML-отчетов
# -V: подробный вывод (view results in browser)
# --use-cc <path_to_clang>: явно указать Clang, если нужно
# --use-c++ <path_to_clang++>: явно указать Clang++, если нужно

# Сначала очистите сборку, если необходимо
# cmake --build build --target clean

scan-build -o ./clang_static_analyzer_reports -V cmake --build build
# или для make:
# scan-build -o ./clang_static_analyzer_reports -V make -j$(nproc)
```
- `scan-build` автоматически попытается использовать `clang` из вашего `PATH`.
- После завершения `scan-build` выведет команду для просмотра результатов в браузере (если используется `-V`) или путь к HTML-отчету.

**Настройка `scan-build`:**
`scan-build` также принимает опции для настройки анализатора, используя префикс `--analyzer-target-option` или через переменные окружения.
```bash
# Пример передачи опций чекера через scan-build
scan-build -o ./reports -V \
    --analyzer-target-option -Xanalyzer \
    --analyzer-target-option -analyzer-checker=security.insecureAPI.gets \
    cmake --build build

# Или через переменные окружения (менее удобно для специфичных опций)
# export CCC_ANALYZER_OPTS="-Xanalyzer -analyzer-checker=security.insecureAPI.gets"
# scan-build ...
```

**В. Интеграция с PyDoit (пример задачи в `dodo.py`):**
```python
# dodo.py (пример)
import os
from doit.tools import CmdAction

BUILD_DIR = "build"
SCAN_BUILD_CMD = "scan-build" # Убедитесь, что доступен в PATH
REPORTS_DIR = "clang_static_analyzer_reports"

# Предполагается, что у вас есть задача для сборки проекта, например, 'build_project'
# def task_build_project(): ...

def task_clang_static_analyze():
    """Run Clang Static Analyzer using scan-build."""
    # Команда сборки, которую scan-build будет оборачивать
    # Важно, чтобы команда сборки использовала Clang
    build_command = f"cmake --build {BUILD_DIR}"
    
    # Опции для scan-build
    # -k: продолжать сборку даже при ошибках (полезно для анализа)
    # --status-bugs: завершиться с ошибкой, если найдены баги (для CI)
    scan_build_options = f"-o {REPORTS_DIR} -k --status-bugs"
    
    # Пример добавления специфичных чекеров (если нужно)
    # analyzer_options = "-Xanalyzer -analyzer-checker=security"
    # cmd = f"{SCAN_BUILD_CMD} {scan_build_options} {analyzer_options} {build_command}"
    cmd = f"{SCAN_BUILD_CMD} {scan_build_options} {build_command}"
    
    return {
        "actions": [
            # Очистка предыдущих отчетов
            f"rm -rf {REPORTS_DIR}", 
            CmdAction(cmd)
        ],
        # Зависит от файлов проекта и конфигурации сборки
        # "file_dep": [...] 
        "task_dep": ["build_project"], # Должен запускаться после конфигурации сборки
        "targets": [os.path.join(REPORTS_DIR, "index.html")], # Основной файл отчета
        "verbosity": 2,
        "doc": "Run Clang Static Analyzer and generate HTML reports."
    }
```
**Примечание по PyDoit:**
- Убедитесь, что `scan-build` и `clang` корректно настроены в вашем Docker-контейнере.
- Задача `build_project` должна конфигурировать и выполнять сборку с использованием Clang, чтобы `scan-build` мог перехватить вызовы компилятора.
- Флаг `--status-bugs` для `scan-build` важен для CI, чтобы задача завершалась с ошибкой при обнаружении проблем.

## 4. Интерпретация результатов

- **HTML-отчеты:** Наиболее удобный способ анализа результатов. `scan-build` генерирует `index.html` в указанной директории отчетов, который содержит список найденных проблем. Каждая проблема сопровождается:
    - Описанием.
    - Местоположением в коде.
    - Визуализацией пути выполнения, который привел к ошибке, с пошаговым объяснением.
- **Текстовый вывод:** Менее информативен, но может быть полезен для быстрой проверки или интеграции с другими инструментами, не поддерживающими HTML.
- **SARIF/plist:** Форматы для интеграции с IDE или системами управления качеством кода, которые их поддерживают.

В CI/CD пайплайне `scan-build` с опцией `--status-bugs` вернет ненулевой код выхода, если анализатор обнаружит какие-либо ошибки, что позволяет автоматически прервать пайплайн.

## 5. Советы по использованию

- **Используйте `scan-build`:** Это наиболее простой и надежный способ интегрировать CSA в процесс сборки.
- **Начните с чекеров по умолчанию:** Не включайте сразу все чекеры, так как это может привести к большому количеству ложных срабатываний и замедлить анализ. Постепенно добавляйте нужные группы чекеров.
- **Регулярно просматривайте отчеты:** Особенно важна визуализация путей выполнения для понимания сложных ошибок.
- **Интегрируйте в CI:** Запускайте `scan-build --status-bugs` в вашем CI-пайплайне.
- **Настройте компиляцию для анализа:** Убедитесь, что ваш проект компилируется с Clang и генерирует отладочную информацию (`-g`), так как это может улучшить качество анализа.
- **Подавление ложных срабатываний:** CSA, как и любой статический анализатор, может давать ложные срабатывания. В коде можно использовать специальные макросы или комментарии для подавления (`ifndef __clang_analyzer__ ... #endif` или `assert()`), но делайте это осознанно.
- **Изучите документацию по чекерам:** Понимание того, что ищет каждый чекер, поможет вам лучше интерпретировать результаты и настраивать анализ.